-- 트랜잭션     =========================================
/*
데이터베이스에서 트랜잭션(Transaction)은 데이터 처리의 한 단위. 

오라클에서 발생하는 여러 개의 SQL 명령문들을 하나의 논리적인 작업 단위로 처리
하는데 이를 트랜잭션이라고 함. 

하나의 트랜잭션은 All-OR-Nothing 방식으로 처리. 

여러 개의 명령어의 집합이 정상적으로 처리되면 정상 종료하도록 하고 
여러 개의 명령어 중에서 하나의 명령어라도 잘못되었다면 전체를 취소.

데이터베이스에서 작업의 단위로 트랜잭션이란 개념을 도입한 이유는 
데이터의 일관성을 유지하면서 안정적으로 데이터를 복구시키기 위해서 
*/

-- 은행 현금인출기(ATM)에서 돈을 인출하는 과정으로 트랜잭션을 설명

--1. 현금을 인출하겠다고 기계에게 알려줌
--2. 현금 카드를 넣어서 본인임을 인증받음
--3. 인출할 금액을 선택하면 은행 현금인출기는 돈을 내어줌
--4. 계좌에서 인출된 금액만큼 잔액에서 차감함

/*
이러한 거래에 있어서 지켜져야 할 중요한 것이 있음. 

기계의 오동작 등으로 인하여 전산 상으로는 돈을 인출한 것으로 입력이 되었는데 
돈은 안 나온다거나, 돈은 나왔는데 일련의 에러나 문제로 인하여서 
돈을 인출한 것이 전산 상으로 입력이 안 되면 상당히 심각한 문제가 발생.

이 때문에 전산 상으로도 입력이 정상적으로 잘 되고, 
돈도 인출이 정상적으로 잘 됨을 확인하고 나서야, 
인출하는 하나의 과정이 정상적으로 처리되었음을 확인할 수 있음.

여기서 돈을 인출하는 일련의 과정이 하나의 묶음으로 처리되어야 한다는 것을 이해.

그리고 혹시 처리도중 중간에 무슨 문제가 발생한다면 
진행되던 인출과정 전체를 취소하고 다시 처음부터 시작해야 함.

이것을 트랜잭션이라고 함.
*/

-- 트랜잭션 제어를 위한 명령어 (Transaction Control Language)

-- COMMIT
-- SAVEPOINT
-- ROLLBACK

-- COMMIT 과 ROLLBACK   ============================== commit, rollback

/*
앞장에서 데이터를 추가, 수정, 삭제하는 작업들을 학습했는데, 
이러한 데이터를 조작하는 명령어인 DML(Data Manipulation Language)은 
이들이 실행됨과 동시에 트랜잭션이 진행됨.

DML 작업이 성공적으로 처리되도록 하기 위해서는 COMMIT 명령을, 
작업을 취소하기 위해서는 ROLLBACK 명령으로 종료.

COMMIT은 모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어로 
트랜잭션의 처리 과정을 데이터베이스에 모두 반영하기 위해서 변경된 내용을 모두 영구 저장.

COMMIT 명령어를 수행하게 되면 하나의 트랜잭션 과정을 종료하게 됨.

ROLLBACK은 
작업 중 문제가 발생되어서 트랜잭션의 처리 과정에서 발생한 변경사항을 취소하는 명령어.

ROLLBACK 명령어 역시 트랜잭션 과정을 종료하게 됨.

ROLLBACK은 트랜잭션으로 인한 하나의 묶음 처리가 시작되기 이전의 상태로 되돌림.

트랜잭션은 여러 개의 물리적인 작업(DML 명령어)들이 모여서 이루어지는데 
이러한 과정에서 하나의 물리적인 작업이라도 문제가 발생하게 되면 
모든 작업을 취소해야 하므로 이들을 하나의 논리적인 작업 단위(트랜잭션)로 구성해 놓는다.

문제가 발생하게 되면 이 논리적인 작업 단위를 취소해 버리면 되기 때문.
*/

-- 여러 개의 DML 명령어들을 어떻게 하나의 논리적인 단위인 트랜잭션으로 묶을 수 있을까?

-- 트랜잭션은 마지막으로 실핸한 커밋(혹은 롤백) 명령어 이후부터
-- 새로운 커밋(혹은 롤백) 명령을 실행하는 시점까지 수행된 모든 DML 명령들을 의미함.

/*

(3)UPDATE 문으로 데이터를 갱신하고,
(4)DELETE 문으로 데이터를 삭제하고,
(5)INSERT 문으로 데이터를 삽입함

만약 이 모든 과정이 오류없이 수행되었다면 지금까지 실행한 모든 작업 (3, 4, 5)을
"데이터베이스에 영구 저장하라" 는 명령으로 커밋을 수행함.

                          |---------- Transction -----------|
(1)INSERT -> (2)DELETE -> (3)UPDATE -> (4)DELETE -> (5)INSERT
                          |                                 |
                        commit                            commit
                    
롤백 명령은 마지막으로 수행한 커밋 명령까지만 정상 처리(1 , 2) 된 상태로 유지하고
그 이후에 수행했던 모든 DML 명령어 작업(3, 4, 5)들을 취소시켜 이전 상태로 원상 복귀시킴.

                          |---------- Transction -----------|
(1)INSERT -> (2)DELETE -> (3)UPDATE -> (4)DELETE -> (5)INSERT
                          | <------------------------------ |
                        commit                            commit

트랜잭션은 이렇듯 ALL-OR-Nothing 방식으로 DML 명령어들을 처리함.

*/
/*
COMMIT 과 ROLLBACK 명령어의 장점

- 데이터 무결성이 보장됨
- 영구적인 변경 전에 데이터의 변경 사항을 확인할 수 있음
- 논리적으로 연관된 작업을 그룹화할 수 있음

- COMMIT 명령어

- Transaction(INSERT, UPDATE, DELETE) 작업 내용을 실제 DB에 저장
- 이전 데이터가 완전히 UPDATE 됨
- 모든 사용자가 변경된 데이터의 결과를 볼 수 있음

- ROLLBACK 명령어

- Transaction(INSERT, UPDATE, DELETE) 작업 내용을 취소
- 이전 COMMIT한 곳 까지만 복구함

데이터베이스 사용자가 COMMIT이나 ROLLBACK 명령어를 명시적으로 수행시키지 않더라도 
다음과 같은 경우에 자동 커밋 혹은 자동 롤백이 발생

- 자동 COMMIT 명령과 자동 ROLLBACK 명령이 되는 경우

-   SQL* PLUS가 정상 종료되었다면 자동으로 COMMIT되지만, 
    비정상 종료되었다면 자동으로 ROLLBACK 합니다.
    
-   DDL과 DCL 명령문이 수행된 경우 자동으로 COMMIT 됨.

-   정전이 발생했거나 컴퓨터 Down시(컴퓨터의 전원이 끊긴) 자동으로 ROLLBACK 됨. 

*/

-- 부서번호가 10번인 부서에 대해서만 삭제하려고 했는데 
-- 테이블 내의 모든 로우가 삭제되어 아무런 데이터도 찾을 수 없게 되었더라도 
-- ROLLBACK 문을 사용하여 이전 상태로 되돌릴 수 있음

-- 1. DELETE문으로 테이블의 레코드들을 삭제

DELETE FROM DEPT01;

-- 2. 만일 부서번호가 20번인 부서에 대해서만 삭제하려고 했는데 
-- 위와 같은 명령을 수행했다면 테이블 내의 모든 로우가 삭제되어 
-- 다음과 같이 아무런 데이터도 찾을 수 없게 됩니다. 
-- 이전 상태로 되돌리기 위해서 ROLLBACK 문을 수행

ROLLBACK;

-- 원래하려고 했던 부서번호가 20번인 부서만 삭제

-- 1. 부서번호 20번 사원에 대한 정보만 삭제한 후, 확인

DELETE FROM DEPT01
WHERE DEPTNO = 20;

-- 2. 데이터를 삭제한 결과를 물리적으로 영구히 저장하기 위해서 커밋을 수행

COMMIT;

-- 자동 커밋 (AUTO COMMIT)============================= auto commit

/*
DDL 문에는 CREATE, ALTER, DROP, RENAME, TRUNCATE 등이 있음. 

이러한 DDL문은 자동으로 커밋(AUTO COMMIT)이 발생됨
*/

-- CREATE문에 의한 자동 커밋에 의해서 이전에 수행했던 DML 명령어가 자동 커밋됨을 확인

-- 1. 부서 번호가 40번인 부서를 삭제

DELETE FROM DEPT02
WHERE DEPTNO = 40;

-- 2. 삭제 후 부서 테이블(DEPT)과 동일한 내용을 갖는 새로운 테이블(DEPT03)을 생성

CREATE TABLE DEPT03
AS
SELECT * FROM DEPT;

-- 3. DEPT02 테이블의 부서번호가 40번인 부서를 다시 되살리기 위해서 
--    ROLLBACK 명령문을 수행하여도 
--    이미 수행한 CREATE 문 때문에 자동으로 커밋이 발생하였으므로 되살릴 수 없다.

-- TRUNCATE 문이  truncate
-- 실패되더라도 자동 커밋되어 이전에 수행했던 DML 명령어가 자동 커밋됨을 확인

-- 1. 부서 테이블(DEPT03)에서 부서 번호가 20번인 부서를 삭제

DELETE FROM DEPT03
WHERE DEPTNO = 20;

-- 2. TRUNCATE 문을 실행시키되 테이블 명을 일부러 잘못 적어서 에러를 유도

TRUNCATE TABLE DEPTPPP;

-- 3. 부서번호가 20번인 부서를 다시 되살리기 위해서 
--    ROLLBACK 명령문을 수행하여도 
--    TRUNCATE 문이 수행되면서 자동으로 커밋이 발생하였으므로 되살릴 수 없다.

-- 트랜잭션을 작게 분할하는 SAVEPOINT  ============================== savepoint
/*
SAVEPOINT 명령을 써서 현재의 트랜잭션을 작게 분할할 수 있음.

저장된 SAVEPOINT는
ROLLBACK TO SAVEPOINT 문을 사용하여 표시한 곳까지 ROLLBACK할 수 있음.

여러 개의 SQL 문의 실행을 수반하는 트랜잭션의 경우, 
사용자가 트랜잭션 중간 단계에서 세이브포인트를 지정할 수 있음. 

이 세이브포인트는 차후 롤백과 함께 사용해서 
현재 트랜잭션 내의 특정 세이브포인트까지 롤백할 수 있게 됨.

아래 그림을 보면 COMMIT 명령이 내려진 후 
다음 COMMIT 명령이 나타날 때까지가 하나의 트랜잭션으로 구성되므로 
(2)번에서 (4)번까지가 하나의 트랜잭션이 됨. 

이렇게 트랙잭션을 구성할 때 
중간 중간 SAVEPOINT 명령으로 위치를 지정해 놓으면
(예를 들어 C) 하나의 트랜잭션 내에서도 
ROLLBACK TO C(SAVEPOINT 문을 사용하여 표시한 곳)까지 ROLLBACK할 수 있음.

                      |======================= Transaction =========================|
(1) DELETE FROM DEPT     DELETE FROM DEPT     DELETE FROM DEPT     DELETE FROM DEPT
    WHERE DEPTNO = 40    WHERE DEPTNO = 30    WHERE DEPTNO = 20    WHERE DEPTNO = 10    
                      |<---------------------|-------------------- | ---------------- ROLLBACK
                      |                      |<------------------- | ---------------- ROLLBACK TO C1 
                      |                      |                     |<-----------------ROLLBACK TO C2
                   COMMIT                SAVEPOINT C1           SAVEPOINT C2

*/

-- SAVEPOINT로 특정 위치를 지정하기 위한 사용 형식

-- SAVEPOINT LABEL_NAME;

-- SAVEPOINT로 지정해 놓은 특정 위치로 되돌아가기 위한 사용 형식

-- ROLLBACK TO LABEL_NAME;

-- 다음과 같이 트랜잭션 중간 단계에서 세이브포인트를 지정
/*
    40번 부서 삭제
                        <--------------- COMMIT
    30번 부서 삭제
                        <--------------- 세이브포인트 C1 설정
    20번 부서 삭제
                        <--------------- 세이브포인트 C2 설정
    10번 부서 삭제
*/

-- 1. 부서번호가 40번인 부서를 삭제한 후에 커밋을 수행하여 새롭게 트랜잭션을 시작

DELETE FROM DEPT01 WHERE DEPTNO=40;
COMMIT;

-- 2. 이번엔 부서번호가 30번인 부서를 삭제

DELETE FROM DEPT01 WHERE DEPTNO=30; 

-- 3. 세이브포인트 C1를 설정한 후, 부서번호가 20번인 사원을 삭제

SAVEPOINT C1; 
DELETE FROM DEPT01 WHERE DEPTNO =20; 

-- 4. 세이브포인트 C2를 설정한 후, 부서번호가 10번인 사원을 삭제

SAVEPOINT C2; 
DELETE FROM DEPT01 WHERE DEPTNO =10;

-- 이제 부서번호가 10번인 사원을 삭제하기 바로 전으로 되돌리려면 어떻게 해야 할까? 
-- 세이브 포인트를 이용해서 트랜잭션 중간 단계로 되돌려보기

-- 1. 지금 ROLLBACK 명령을 내리게 된다면 이전 COMMIT 지점으로 되돌아가므로 
--    10, 20, 30번 부서의 삭제가 모두 취소됨. 
--    따라서 원했던 10번 부서의 삭제 이전까지만 되돌리려면 
--    다시 30, 20번의 부서를 삭제해 주어야 할 것입니다.

ROLLBACK TO C2; 

-- 2. 위 결과 화면을 보면 세이브포인트 C2 지점으로 이동되어 
--    10번 부서의 삭제 이전으로 되돌려진 것을 확인할 수 있음

ROLLBACK TO C1; 

-- 3. 마지막으로 이전 트랜잭션까지 롤백한 후의 결과 확인

ROLLBACK; 
