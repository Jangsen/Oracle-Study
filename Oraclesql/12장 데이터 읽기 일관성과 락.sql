-- 데이터 읽기 일관성과 락
/*
오라클이 데이터 읽기의 일관성을 제공해 준다는 것을 증명을 하기 위해서 
우선 다음과 같은 가정. 
오라클 서버가 서울 본사에 설치되어 있고 
이 데이터베이스를 서울 본사 직원과 대전 지사 직원이 공용하고 있다. 
어느 날 서울 본사 직원과 대전 지사 직원이 
동일한 테이블을 같은 시간에 접근해서 사용할 경우 
어떤 일이 일어날 수 있는지 살펴보기.

======================락 Lock    ===========================
사용자    서울본사직원(철수)         대전지사직원(영희)

① SELECT * FROM EMP01 
    WHERE ENAME='SCOTT';
                                 ② DELETE FROM EMP01
                                    WHERE ENAME='SCOTT';    오라클은 SCOTT 사원이 
                                                            삭제되기 전에 자동으로 
                                                            롤백 세그먼트에 이 행의 정보를 
                                                            Before Image(복사 본)로 복사해둔다. 

영희에 의해 삭제된 행을 철수가 접근해서 
그 내용을 변경한다는 것은 
이치에 맞지 않기 때문에 
락이 걸려 무한 대기 상태가 된다.

③ UPDATE EMP01 
   SET SAL=200 
   WHERE ENAME='SCOTT';
LOCKING(무한대기상태)....
                                 ④ ROLLBACK;        영희가 SCOTT 사원을 삭제하는 
                                                     쿼리문에 대해 커밋이나 롤백을 해야만 
                                                     철수가 SCOTT 사원의 정보를 
                                                     변경할 수 있게 된다. 
                                                     철수가 롤백을 수행하면 
                                                     SCOTT 사원을 삭제하겠다는 
                                                     명령문을 해제하게 되어 
                                                     롤백 세그먼트에 
                                                     저장된 복사 본이 원상 복귀된다.


⑤ 무한대기에서 벗어남 

영희가 트랙잭션을 종료하였기에 
무한 대기에서 벗어나게 되고 
철수에 의해 SCOTT 사원의 급여가
200으로 변경된다.

============= 데드 락 Dead Lock    ===================

사용자    서울본사직원(철수)         대전지사직원(영희)

① UPDATE emp SET sal=100
  WHERE ename ='SCOTT';
                                    ② UPDATE emp SET sal=20
                                       WHERE ENAME='SMITH';


③ UPDATE emp SET sal=300 
   WHERE ename ='SMITH';
LOCKING(무한대기상태)....

Ename이 SMITH인 행이 
영희에 의해 갱신명령어를 수행했기에 
철수가 락에 걸림 .
                                    ④ UPDATE emp SET sal=400 
                                       WHERE ename ='SCOTT';
                                      LOCKING(무한대기상태)....
                                    
                                    영희가 커밋이나 롤백을 하지 않고 
                                    철수가 사용중인 SCOTT에 접근하려고 하면 
                                    어느 한쪽의 작업도 완료할 수 없는 상태인 
                                    데드 락에 빠지게 됨.

서로의 행에 대한 접근을 하려 하고 있으므로 
결과적으로 어느 한 쪽도 작업을 완료할 수 없는 상태에 빠지게 된다.

Oracle에서는 이 상태를 방지하기 위한 해결책으로 
다음과 같은 메시지를 보내면서 비정상적인 종료를 하고 그로 인한 자동 롤백이 이루어진다.

ORA-00060:?deadlock detected while waiting for resource
(자원 대기 중 교착상태가 검출되었습니다.)

결과적으로 철수의 3번 명령을 취소시킴으로써 데드락 상태에서 빠져 나오게 된다.
명령문마다 암시적인 세이브 포인터를 지니고 있다가 
데드락 을 벗어나기 위해서 세이브포인터까지 롤백하게 되는 것이다.

=================== LOCK 과 TCL  ============================

    커밋(Commit)                          롤백(RollBck)
    
    트랜잭션을 데이터베이스에 반영           트랜잭션을 데이터베이스에 취소
    락을 해제                              락을 해제
    트랜잭션이 종료                        트랜잭션이 종료
    자동 커밋(Auto Commit)은 정상 종료      자동 롤백(Auto Rollback)은 비정상 종료
    

테이블 갱신 시 발생한 락 해결 방법

문제 제시

  ALTER TABLE  테이블명  DROP  COLUMN  컬럼명;

삭제가 진행되는 시점에서 다른 사용자가 DML명령어로 접근한다면 락이 걸림

SET UNUSED

근무시간에 다른 사용자가 접근하지 못하도록 제한만 둔다

ALTER TABLE 테이블명 SET UNUSED(컬럼명);

시스템 사용 빈도가 적을 때 실질적인 삭제를 한다. 

ALTER TABLE 테이블명 DROP UNUSED COLUMN;

================DDL 명령의 롤백  =========================

자동 커밋

DDL 문은 자동 커밋이 발생하므로 이전 상태로 롤백할 수 없다.  

테이블을 복사해두었다가 
변경된 내용의 테이블을 작성 후 복사해 두었던 테이블의 이름을 변경한다. 


================TRUNCATE와 DELETE 차이  =========================

TRUNCATE
DDL 문으로 자동 커밋 발생, 삭제 이전으로 롤백 할 수 없다.
테이블의 구조만 남고 모든 레코드가 삭제된다. 

DELETE
DML 문으로 삭제 이전으로 롤백 할 수 있다.
삭제하고자 하는 레코드를 선택할 수 있다. 

